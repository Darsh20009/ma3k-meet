// Enhanced Virtual Participants with Arabic AI-like responses
import { nanoid } from 'nanoid';

export interface VirtualParticipant {
  id: string;
  name: string;
  avatar: string;
  status: 'active' | 'away' | 'offline';
  personality: 'professional' | 'friendly' | 'technical' | 'creative' | 'manager';
  joinTime?: Date;
  lastMessageTime?: Date;
}

export interface MessagePattern {
  triggers: string[];
  responses: string[];
  delay: number; // milliseconds
  priority: number;
}

// Enhanced Arabic message patterns for different personalities
const MESSAGE_PATTERNS: Record<string, MessagePattern[]> = {
  professional: [
    {
      triggers: ['ูุฑุญุจุง', 'ุฃููุง', 'ุงูุณูุงู ุนูููู', 'ุตุจุงุญ ุงูุฎูุฑ', 'ูุณุงุก ุงูุฎูุฑ'],
      responses: [
        'ูุฑุญุจุงู ุจุงูุฌููุนุ ุณุนูุฏ ุจุงููุดุงุฑูุฉ ูู ูุฐุง ุงูุงุฌุชูุงุน ุงูููู',
        'ุฃููุงู ูุณููุงูุ ุฃุชุทูุน ููููุงูุดุฉ ุงููุนุงูุฉ ุงูููู',
        'ุงูุณูุงู ุนูููู ูุฑุญูุฉ ุงูููุ ุฌุงูุฒ ููุจุฏุก',
        'ุตุจุงุญ ุงูุฎูุฑุ ุฏุนููุง ูุจุฏุฃ ุจููุงูุดุฉ ุงูููุงุท ุงูุฑุฆูุณูุฉ'
      ],
      delay: 2000,
      priority: 1
    },
    {
      triggers: ['ุงููุดุฑูุน', 'ุงูุชุทููุฑ', 'ุงูุนูู', 'ุงููููุฉ'],
      responses: [
        'ุจุงููุณุจุฉ ูููุดุฑูุนุ ุฃุนุชูุฏ ุฃููุง ุจุญุงุฌุฉ ูุชุญุฏูุฏ ุงูุฃููููุงุช',
        'ูููููุง ุชูุณูู ุงูุนูู ุฅูู ูุฑุงุญู ูุงุจูุฉ ููุชูููุฐ',
        'ูุฏู ุจุนุถ ุงูุงูุชุฑุงุญุงุช ูุชุญุณูู ุณูุฑ ุงูุนูู',
        'ูุง ุฑุฃููู ูู ูุถุน ุฌุฏูู ุฒููู ูุงุถุญ ููููุงูุ'
      ],
      delay: 3000,
      priority: 2
    }
  ],
  friendly: [
    {
      triggers: ['ูุฑุญุจุง', 'ุฃููุง', 'ูุงู', 'ูููู'],
      responses: [
        'ูุฑุญุจุง ุญุจูุจู! ููู ุงูุฃุญูุงูุ ๐',
        'ุฃููุงู ุฃููุงู! ููุฑุช ุงูุงุฌุชูุงุน',
        'ูุงุงุงู! ูุญุดุชูููุ ููููู ุงููููุ',
        'ุฃูููู! ุดูููููุ ุฅู ุดุงุก ุงููู ุชูุงู'
      ],
      delay: 1500,
      priority: 1
    },
    {
      triggers: ['ุดูุฑุง', 'ููุชุงุฒ', 'ุฑุงุฆุน', 'ุฌููู'],
      responses: [
        'ุนููุงู ุญุจูุจูุ ูุฐุง ุฃูู ูุงุฌุจ! โค๏ธ',
        'ุงููู ูุนุทูู ุงูุนุงููุฉ! ุฃูุช ุงูุฃุฑูุน',
        'ูุง ุดุงุก ุงููู ุนูููุ ุฏุงููุงู ูุจุฏุน',
        'ูุฐุง ูู ุฐููู ุงูุญูู! ๐'
      ],
      delay: 2000,
      priority: 2
    }
  ],
  technical: [
    {
      triggers: ['ููุฏ', 'ุจุฑูุฌุฉ', 'ุชูููุฉ', 'API', 'database', 'ุณูุฑูุฑ'],
      responses: [
        'ุจุงููุณุจุฉ ููููุฏุ ุฃูุชุฑุญ ุงุณุชุฎุฏุงู TypeScript ูุถูุงู type safety',
        'ูููููุง ุชุญุณูู ุงูุฃุฏุงุก ุจุงุณุชุฎุฏุงู caching mechanisms',
        'ูุง ุฑุฃููู ูู ุชุทุจูู Clean Architecture patternsุ',
        'ูุญุชุงุฌ ููุฑุงุฌุนุฉ ุงูู API design patterns ุงููุณุชุฎุฏูุฉ'
      ],
      delay: 4000,
      priority: 2
    },
    {
      triggers: ['ูุดููุฉ', 'ุฎุทุฃ', 'bug', 'error'],
      responses: [
        'ุฏุนูู ุฃุญูู ุงูููุฏ ูุฃุฌุฏ ุงูุณุจุจ ูู ุงููุดููุฉ',
        'ูุจุฏู ุฃู ููุงู memory leak ูู ุงูู application',
        'ุงููุดููุฉ ูุฏ ุชููู ูู ุงูู database connection pool',
        'ุฃุนุชูุฏ ุฃู ุงูุญู ูู ุชุญุณูู exception handling'
      ],
      delay: 5000,
      priority: 3
    }
  ],
  creative: [
    {
      triggers: ['ุชุตููู', 'ููุฑุฉ', 'ุฅุจุฏุงุน', 'UI', 'UX', 'ุฃููุงู'],
      responses: [
        'ูุฏู ููุฑุฉ ุฅุจุฏุงุนูุฉ! ูุง ุฑุฃููู ูู gradient backgrounds ูุน glassmorphismุ',
        'ูููููุง ุฅุถุงูุฉ micro-animations ูุชุญุณูู user experience',
        'ุฃูุชุฑุญ ุงุณุชุฎุฏุงู color psychology ูู ุชุตููู ุงููุงุฌูุฉ',
        'ุฏุนููุง ูููุฑ ูู innovative interaction patterns! ๐จ'
      ],
      delay: 3000,
      priority: 2
    },
    {
      triggers: ['ูุณุชุฎุฏู', 'ุชุฌุฑุจุฉ', 'ูุงุฌูุฉ', 'ุชูุงุนู'],
      responses: [
        'ุงูุชุฌุฑุจุฉ ูุฌุจ ุฃู ุชููู intuitive ู engaging ูููุณุชุฎุฏููู',
        'ูุง ุฑุฃููู ูู ุฅุถุงูุฉ accessibility featuresุ',
        'ูููููุง ุนูู A/B testing ูููุงุณ effectiveness ุงูุชุตููู',
        'ุฃุญุจ ููุฑุฉ personalized user journeys! โจ'
      ],
      delay: 3500,
      priority: 2
    }
  ],
  manager: [
    {
      triggers: ['ุฎุทุฉ', 'ุงุณุชุฑุงุชูุฌูุฉ', 'ูุฏู', 'ูุชุงุฆุฌ', 'ุชูุฑูุฑ'],
      responses: [
        'ูุญุชุงุฌ ููุถุน roadmap ูุงุถุญ ูุชุญููู ุงูุฃูุฏุงู ุงููุทููุจุฉ',
        'ุฏุนููุง ูุฑุงุฌุน KPIs ูุงูู metrics ุงูุฎุงุตุฉ ุจุงููุดุฑูุน',
        'ูุง ูู ุงูุชุญุฏูุงุช ุงูุชู ุชูุงุฌููููุง ูู ุงูุชูููุฐุ',
        'ุฃูุชุฑุญ ุนูุฏ ุงุฌุชูุงุนุงุช ูุชุงุจุนุฉ ุฃุณุจูุนูุฉ ูุถูุงู ุงูุชูุฏู'
      ],
      delay: 3500,
      priority: 2
    },
    {
      triggers: ['ูุฑูู', 'ุชุนุงูู', 'ูุณุคูููุฉ', 'ุชูููู'],
      responses: [
        'ุงููุฑูู ูุญุชุงุฌ ูุชูุฒูุน ูุงุถุญ ูููุณุคูููุงุช ูุงูุฃุฏูุงุฑ',
        'ูุง ุฑุฃููู ูู ุชุทุจูู agile methodologyุ',
        'ูุญู ุจุญุงุฌุฉ ูุชุญุณูู communication channels ุจูู ุงูุฃุนุถุงุก',
        'ุฏุนููุง ูุญุฏุฏ timeline ูุงุถุญ ูุน milestones ูุงุจูุฉ ููููุงุณ'
      ],
      delay: 4000,
      priority: 3
    }
  ]
};

// Contextual responses based on meeting activity
const CONTEXTUAL_RESPONSES = {
  welcomeMessages: [
    'ูุฑุญุจุงู ุจุงูุฌููุน ูู ูุฐุง ุงูุงุฌุชูุงุน ุงููุซูุฑ',
    'ุฃููุงู ูุณููุงูุ ุณุนูุฏ ุจูุฌูุฏูู ูุนูุง ุงูููู',
    'ุจุณู ุงููู ูุจุฏุฃุ ุฃุชููู ููู ุฌูุณุฉ ูููุฏุฉ',
    'ุงูุณูุงู ุนููููุ ููุจุฏุฃ ุจุงูููุงุท ุงููููุฉ ุนูู ุงูุฃุฌูุฏุฉ'
  ],
  agreementPhrases: [
    'ุฃุชูู ูุนู ุชูุงูุงู ูู ูุฐู ุงูููุทุฉ',
    'ููุฑุฉ ููุชุงุฒุฉุ ุฃุคูุฏู ูููุง',
    'ูุฐุง ุชุญููู ุตุญูุญ ูููุทูู',
    'ูุนู ุจุงูุถุจุทุ ูุฐุง ูุง ููุช ุฃููุฑ ููู'
  ],
  questionResponses: [
    'ุณุคุงู ุฌูุฏุ ุฏุนูู ุฃููุฑ ูู ุงูุฅุฌุงุจุฉ',
    'ูุฐู ููุทุฉ ูููุฉ ุชุณุชุญู ุงูููุงูุดุฉ',
    'ุฃุนุชูุฏ ุฃู ุงูุฌูุงุจ ูููู ูู...',
    'ูู ูุฌูุฉ ูุธุฑูุ ูููููุง ุงูููู ุฃู...'
  ],
  closingMessages: [
    'ุดูุฑุงู ููู ุฌููุนุงู ุนูู ูุฐุง ุงูุงุฌุชูุงุน ุงููููุฏ',
    'ูุงู ููุงุกู ูุซูุฑุงูุ ุจุงูุชูููู ููุฌููุน',
    'ุฃุชุทูุน ูููุชุงุจุนุฉ ูู ุงูุงุฌุชูุงุน ุงููุงุฏู',
    'ุฏูุชู ุจุฎูุฑุ ููุชูุงุตู ูุฑูุจุงู ุฅู ุดุงุก ุงููู'
  ]
};

// Generate random virtual participants with diverse personalities
export function generateVirtualParticipants(count: number = 6): VirtualParticipant[] {
  const names = [
    'ุฃุญูุฏ ุงููููุฏุณ', 'ูุงุทูุฉ ุงููุตููุฉ', 'ูุญูุฏ ุงููุทูุฑ',
    'ููุฑ ุงููุฏูุฑุฉ', 'ุนุจุฏุงููู ุงููุญูู', 'ุณุงุฑุฉ ุงููุณููุฉ',
    'ุฎุงูุฏ ุงูุงุณุชุดุงุฑู', 'ูุฑูู ุงูุฎุจูุฑุฉ', 'ููุณู ุงูููุณู',
    'ุฏุนุงุก ุงููุฎุชุตุฉ', 'ุนูุฑ ุงูุฃุฎุตุงุฆู', 'ููุฏ ุงููุดุฑูุฉ'
  ];
  
  const avatars = ['๐จโ๐ผ', '๐ฉโ๐ผ', '๐จโ๐ป', '๐ฉโ๐ป', '๐จโ๐ฌ', '๐ฉโ๐ฌ', '๐จโ๐จ', '๐ฉโ๐จ', '๐จโ๐ซ', '๐ฉโ๐ซ', '๐จโโ๏ธ', '๐ฉโโ๏ธ'];
  const personalities: Array<'professional' | 'friendly' | 'technical' | 'creative' | 'manager'> = 
    ['professional', 'friendly', 'technical', 'creative', 'manager'];

  return Array.from({ length: Math.min(count, names.length) }, (_, i) => ({
    id: nanoid(),
    name: names[i],
    avatar: avatars[i % avatars.length],
    status: Math.random() > 0.8 ? 'away' : 'active' as const,
    personality: personalities[i % personalities.length],
    joinTime: new Date(Date.now() - Math.random() * 300000), // Joined in last 5 minutes
  }));
}

// Enhanced AI response generation
export class VirtualParticipantAI {
  private participants: VirtualParticipant[];
  private messageHistory: Array<{ content: string; timestamp: Date; sender: string }> = [];
  private lastResponseTime = 0;
  private conversationContext: string[] = [];

  constructor(participants: VirtualParticipant[]) {
    this.participants = participants;
  }

  // Generate intelligent response based on context and personality
  generateResponse(trigger: string, speed: 'slow' | 'medium' | 'fast' = 'medium'): {
    participant: VirtualParticipant;
    message: string;
    delay: number;
  } | null {
    // Prevent too frequent responses
    const now = Date.now();
    const minInterval = speed === 'fast' ? 3000 : speed === 'medium' ? 8000 : 15000;
    
    if (now - this.lastResponseTime < minInterval) {
      return null;
    }

    // Find active participants
    const activeParticipants = this.participants.filter(p => p.status === 'active');
    if (activeParticipants.length === 0) return null;

    // Select participant based on personality relevance
    const relevantParticipant = this.selectRelevantParticipant(trigger, activeParticipants);
    if (!relevantParticipant) return null;

    // Generate contextual response
    const response = this.generateContextualResponse(trigger, relevantParticipant.personality);
    if (!response) return null;

    this.lastResponseTime = now;
    
    // Update conversation context
    this.conversationContext.push(trigger);
    if (this.conversationContext.length > 10) {
      this.conversationContext = this.conversationContext.slice(-10);
    }

    return {
      participant: relevantParticipant,
      message: response.message,
      delay: response.delay
    };
  }

  private selectRelevantParticipant(trigger: string, participants: VirtualParticipant[]): VirtualParticipant | null {
    // Weight participants based on trigger relevance
    const weights = participants.map(p => {
      const patterns = MESSAGE_PATTERNS[p.personality] || [];
      let relevanceScore = 0;
      
      patterns.forEach(pattern => {
        const matches = pattern.triggers.filter(t => trigger.includes(t)).length;
        relevanceScore += matches * pattern.priority;
      });
      
      // Add randomness to avoid same participant always responding
      relevanceScore += Math.random() * 2;
      
      return { participant: p, weight: relevanceScore };
    });

    // Sort by weight and select from top candidates
    weights.sort((a, b) => b.weight - a.weight);
    const topCandidates = weights.slice(0, Math.min(3, weights.length));
    
    if (topCandidates.length === 0 || topCandidates[0].weight === 0) {
      return participants[Math.floor(Math.random() * participants.length)];
    }

    return topCandidates[Math.floor(Math.random() * topCandidates.length)].participant;
  }

  private generateContextualResponse(trigger: string, personality: string): { message: string; delay: number } | null {
    const patterns = MESSAGE_PATTERNS[personality] || [];
    
    // Find matching patterns
    const matchingPatterns = patterns.filter(pattern => 
      pattern.triggers.some(t => trigger.toLowerCase().includes(t.toLowerCase()))
    );

    if (matchingPatterns.length > 0) {
      // Select pattern based on priority
      const selectedPattern = matchingPatterns.sort((a, b) => b.priority - a.priority)[0];
      const response = selectedPattern.responses[Math.floor(Math.random() * selectedPattern.responses.length)];
      
      return {
        message: this.enhanceResponseWithContext(response),
        delay: selectedPattern.delay + Math.random() * 1000
      };
    }

    // Generate contextual response if no specific pattern matches
    return this.generateGenericResponse(personality);
  }

  private enhanceResponseWithContext(baseResponse: string): string {
    // Add contextual elements based on recent conversation
    const contextKeywords = this.conversationContext.join(' ').toLowerCase();
    
    if (contextKeywords.includes('ุดูุฑุง')) {
      return baseResponse + ' ูุดูุฑุงู ูู ุฃูุถุงู';
    }
    
    if (contextKeywords.includes('ูุดุฑูุน') || contextKeywords.includes('ุนูู')) {
      return baseResponse + ' ูููุถุน ุฎุทุฉ ุนูููุฉ ููุชูููุฐ';
    }
    
    return baseResponse;
  }

  private generateGenericResponse(personality: string): { message: string; delay: number } | null {
    const generic = {
      professional: [
        'ูุฐู ููุทุฉ ูููุฉ ุชุณุชุญู ุงูุฏุฑุงุณุฉ',
        'ุฃุชูู ูุน ุงูุชูุฌู ุงูุนุงู ููููุงูุดุฉ',
        'ุฏุนููุง ูุฑูุฒ ุนูู ุงูุฌูุงูุจ ุงูุนูููุฉ',
        'ูุง ุฑุฃููู ูู ุชุญุฏูุฏ ุงูุฎุทูุงุช ุงูุชุงููุฉุ'
      ],
      friendly: [
        'ุฑุฃู ุฌููู! ุฃุญุจ ูุฐุง ุงูุชูููุฑ ๐',
        'ูุง ุดุงุก ุงููู ุนููููุ ุฃููุงุฑ ุฑุงุฆุนุฉ',
        'ูุฐุง ูุฐูุฑูู ุจุชุฌุฑุจุฉ ูุดุงุจูุฉ ูุฑุฑุช ุจูุง',
        'ุตุฑุงุญุฉ ููุถูุน ูุณุชุญู ุงูููุงุด ุฃูุซุฑ'
      ],
      technical: [
        'ูู ุงููุงุญูุฉ ุงูุชูููุฉุ ูุฐุง feasible',
        'ูุญุชุงุฌ ููุฑุงุฌุนุฉ technical requirements',
        'ูููููุง ุชุทุจูู ูุฐุง ุจุงุณุชุฎุฏุงู best practices',
        'ุงูููุฑุฉ ุฌูุฏุฉุ ููู ูุญุชุงุฌ optimization'
      ],
      creative: [
        'ููุฑุฉ ูุจุฏุนุฉ! ูููููุง ุชุทููุฑูุง ุฃูุซุฑ โจ',
        'ุฃุญุจ ุงูุงุจุชูุงุฑ ูู ูุฐุง ุงูุชูุฌู',
        'ูุง ุฑุฃููู ูู ุฃุถููุง ููุณุฉ ุฅุจุฏุงุนูุฉุ',
        'ูุฐุง ููุชุญ ุขูุงู ุฌุฏูุฏุฉ ููุชุทููุฑ'
      ],
      manager: [
        'ูุญุชุงุฌ ูููุงุณ ุชุฃุซูุฑ ูุฐุง ุงููุฑุงุฑ ุนูู ุงูู timeline',
        'ูุง ูู ุงูููุงุฑุฏ ุงููุทููุจุฉ ูุชูููุฐ ูุฐุงุ',
        'ุฏุนููุง ูุญุฏุฏ ุงููุณุคูููุงุช ุจูุถูุญ',
        'ุฃูุชุฑุญ ูุฑุงุฌุนุฉ ูุฐุง ูู ุงูุงุฌุชูุงุน ุงููุงุฏู'
      ]
    };

    const responses = generic[personality as keyof typeof generic] || generic.professional;
    const message = responses[Math.floor(Math.random() * responses.length)];
    
    return {
      message,
      delay: 3000 + Math.random() * 2000
    };
  }

  // Simulate participant joining/leaving
  updateParticipantStatus(participantId: string, status: 'active' | 'away' | 'offline') {
    const participant = this.participants.find(p => p.id === participantId);
    if (participant) {
      participant.status = status;
    }
  }

  // Get conversation summary for context
  getConversationSummary(): string {
    return this.conversationContext.slice(-5).join(' ');
  }

  // Auto-generate opening messages when meeting starts
  generateWelcomeMessages(): Array<{ participant: VirtualParticipant; message: string; delay: number }> {
    const activeParticipants = this.participants.filter(p => p.status === 'active').slice(0, 3);
    
    return activeParticipants.map((participant, index) => ({
      participant,
      message: CONTEXTUAL_RESPONSES.welcomeMessages[index % CONTEXTUAL_RESPONSES.welcomeMessages.length],
      delay: (index + 1) * 2000 + Math.random() * 1000
    }));
  }
}